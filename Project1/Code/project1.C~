/*
Elizabeth Drueke
PHY 480
February 12, 2016

Project 1

This script solves the 1d Poisson Equation -u''(x)=f(x) for 0<x<1 subject to
the Dirichlet boundary conditions u(0)=u(1)=0 for f(x)=100e**(-10*x).
*/

#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>

#include "TGraph.h"
#include "TCanvas.h"
#include "TMultiGraph.h"
#include "TLegend.h"
#include "TStyle.h"

using namespace std;

//dim is a global variable giving the dimension of the nxn matrices
const int dim = 2;

double **MakeMatr(vector<double> thevec){
  /*Takes in a vector of the components of a dim x dim matrix and returns
    a matrix of those components.*/

  double **to_ret;
  to_ret = new double*[dim];
  for(int i=0;i<dim;i++){
    to_ret[i] = new double[dim];
  }

  int row = 0;
  int column = 0;
  for(unsigned int i=0;i<thevec.size();i++){
    if(i%dim==0 && i!=0){
      row+=1;
      column = 0;
    }

    to_ret[row][column] = thevec.at(i);

    column+=1;
  }

  return to_ret;
}

double *MakeVector(vector<double> thevec){
  /*Takes in a vector of the components of a dim-dimensional vector and 
    returns an array of those components.
  */

  double *to_ret;
  to_ret = new double[dim];
  for(unsigned int i=0;i<dim;i++)
    to_ret[i]=thevec.at(i);

  return to_ret;
}

//double first_deriv(double &x, double &h){
//  /*Takes in 
//    and returns the first derivative*/
//  
//  return 0;
//}
//
//double second_deriv(double &x, double &h){
//  /*Takes in
//    and returns the second derivative.*/
//
//  return 0;
//}

double** mat_mat_mult(double **matr1, double **matr2){
  /*Takes in 2 matrices and returns their multiplication*/

  double **matr;
  matr = new double*[dim];
  for(int i=0;i<dim;i++)
    matr[i]=new double[dim];
  
  for(int i=0;i<dim;i++){
    for(int j=0;j<dim;j++){
      matr[i][j]=0;
      for(int k=0;k<dim;k++){
	matr[i][j]+=matr1[i][k]*matr2[k][j];
      }
    }
  }

  return matr;
}

double* mat_vec_mult(double **matr1, double *vec1){
  /*Takes in a matrix and a vector and returns their multiplication.*/

  double *vec;
  vec = new double[dim];
  for(int i=0;i<dim;i++){
    vec[i]=0;
    for(int j=0;j<dim;j++){
      vec[i]+=matr1[i][j]*vec1[j];
    }
  }

  return vec;
}

//What if there is an arbitrary 0 entry? 
double one_forw_reduc(double matr[][dim], double vec[]){
  /*Takes in a matrix and a vector and performs one forward reduction, whose
    matrix and vector it then returns.*/
  
  //Determine what row needs to be reduced.
  int i=0;
  while(i+1<dim and matr[i+1][i]==0){
    i++;
  }

  //If the matrix is fully reduced (forward), then return the matrix.
  if(i+1==dim)
    return matr,vec;
  
  //Else, reduce by the next row.
  double matr_ret[dim][dim];
  double vec_ret[dim];
  for(int j=0;j<i;j++){
    vec_ret[j]=vec[j];
    for(int k=0;k<dim;k++){
      matr_ret[j][k]=matr[j][k];
    }
  }

  for(int j=i;j<dim;j++){
    double fact = matr[j][i]/matr[i][i];
    vec_ret[j]=vec[j]-vec[i]*fact;
    for(int k=0;k<dim;k++){
      if(matr[j][k]==0)
	matr_ret[j][k]=0;
      else{
	matr_ret[j][k]=matr[j][k]-matr[i]*fact;
      }
    }
  }

  //Can I return this? Doubtful. Probably need to work solely with pointers.
  return matr_ret,vec_ret;
}

//What if there is an arbitrary 0 entry? 
vector<vector<double> > one_back_reduc(double **matr, double *vec){
  /*Takes in a matrix and a vector and performs one backward reduction, whose
    matrix and vector it then returns.*/
  
  //Determine what row needs to be reduced.
  int i=dim-1;
  while(i-1>-1 and matr[i-1][i]==0){
    i--;
  }

  //If the matrix is fully reduced (forward), then return the matrix.
  if(i-1==0)
    return matr,vec;
  
  //Else, reduce by the next row.
  double **matr_ret;
  matr_ret = new double*[dim];
  double *vec_ret;
  vec_ret = new double[dim];
  for(int i=0;i<dim;i++){
    matr_ret[i]=new double[dim];
  }

  for(int j=dim-1;j>i;j--){
    vec_ret[j]=vec[j];
    for(int k=0;k<dim;k++){
      matr_ret[j][k]=matr[j][k];
    }
  }

  for(int j=i;j>0;j--){
    double fact = matr[j][i]/matr[i][i];
    vec_ret[j]=vec[j]-vec[i]*fact;
    for(int k=0;k<dim;k++){
      matr_ret[j][k]=0;
    }
  }

  vector<double> vec_to_ret,matr_to_ret;
  for(int i=0;i<dim;i++){
    vec_to_ret.push_back(vec[i]);
    for(int j=0;j<dim;j++){
      matr_to_ret.push_back(matr_ret[i][j]);
    }
  }

  vector<vector<double> > to_ret;
  to_ret.push_back(vec_to_ret, matr_to_ret);
  return to_ret;
}

double *gauss_elim(double **matr1,double vec){
  /*Takes in a matrix and a vector (the solution to Ax=b) and returns the 
    vector x which is the solution to this problem, found by Gaussian 
    elimination.*/

  //First to perform forward elimination.
  double **matr_ret = matr1;
  double *vec_ret = vec;
  for(int i=0;i<dim;i++){
    vector<vector<double> > returned = one_forw_reduc(matr_ret,vec_ret);
    matr_ret = MakeMatrix(returned.at(1));
    vec_ret = MakeVector(returned.at(0));
  }

  //Then perform backward elimination.
  for(int i=0;i<dim;i++){
    //HERE NEED TO MAKE THE RETURN A VECTOR OF VECTOR OF DOUBLES AND MAKE THE MATRIX AND VECTOR FROM THAT AS IN ABOVE LOOP.
    matr_ret, vec_ret = one_back_reduc(matr_ret,vec_ret);
  }

  //Then compute the solution x
  double *x;
  x = new double[dim];
  for(int i=0;i<dim;i++){
    x[i]=vec_ret[i]/matr_ret[i];
  }

  return vec_ret;
}

//Need to double-check this algorithm.
vector<vector<double> > LU_decomp(double **matr){
  /*Takes in a matrix and returns the LU decomposition as a pair of pointers 
    (L,U) (?).*/

  double **L; double **U;
  L = new double*[dim]; U = new double*[dim];
  for(int i=0;i<dim;i++){
    L[i] = new double[dim];
    U[i] = new double[dim];
  }

  //Predefined 0's and 1's:
  for(int i=0;i<dim;i++){
    for(int j=0;j<dim;j++){
      if(i==j)
	L[i][j]=1;
      else if(i > j)
	U[i][j]=0;
      else
	L[i][j]=0;
    }
  }

  //First, U_1j = matr_1j
  for(int i=0;i<dim;i++){
    U[1][i]=matr[1][i];
  }

  //Then U_ij = matr_ij - sum(l_ik*u_kj,k,1,i-1)
  for(int j=0;j<dim;j++){
    for(int i=0;i<j;i++){
      U[i][j]=matr[i][j];
      for(int k=0;k<i-2;k++){
	U[i][j]-=L[i][k]*U[k][j];
      }
    }
  }

  //Then U_jj = ajj - sum(l_jk*u_kj,k,1,j-1)
  for(int j=0;j<dim;j++){
    U[j][j]=matr[j][j];
    for(int k=0;k<j-2;k++){
      U[j][j]-=L[j][k]*U[k][j];
    }
  }

  //Finally, for i>j, L_ij = (1/U_ij)*(matr_ij - sum(l_ik*u_kj,k,1,i-1))
  for(int j=0;j<dim;j++){
    for(int i=j+1;i<dim;i++){
      L[i][j]=matr[i][j]/U[j][j];
      for(int k=0;k<i-2;k++){
	L[i][j]-=L[i][k]*U[i][k]/U[j][j];
      }
    }
  }

  vector<vector<double> > to_ret;
  vector<double> L_ret, U_ret;

  for(int i=0;i<dim;i++){
    for(int j=0;j<dim;j++){
      L_ret.push_back(L[i][j]);
      U_ret.push_back(U[i][j]);
    }
  }

  to_ret.push_back(L_ret);
  to_ret.push_back(U_ret);
  
  for(int i=0;i<dim;i++){
    delete [] L[i];
    delete [] U[i];
  }

  delete [] L;
  delete [] U;

  return to_ret;
}

void PrintVector(double *vec){
  /*
    Print the components of the vector.
  */

  for(int i=0;i<dim;i++){
    cout<<vec[i]<<", ";
  }
  cout<<endl<<endl;
}

void PrintMatr(double **matr){
  /*Print the components of the vector.*/

  for(int i=0;i<dim;i++){
    for(int j=0;j<dim;j++){
      cout<<matr[i][j]<<", ";
    }
    cout<<endl;
  }
  cout<<endl;
}

void project1(){
  /*The main function of the script.*/

  double *vec;
  vec = new double[dim];

  double **matr;
  matr = new double*[dim];

  for(int i=0;i<dim;i++){
    matr[i] = new double[dim];
  }

  for(int i=0;i<dim;i++){
    vec[i]=1;
  }
  matr[0][0]=1; matr[0][1]=1; matr[1][0]=2; matr[1][1]=-1;

  PrintMatr(matr);
  PrintVector(vec);

  double** matr_product = mat_mat_mult(matr,matr);
  PrintMatr(matr_product);
  double* vec_product = mat_vec_mult(matr,vec);
  PrintVector(vec_product);


  vector<vector<double> > LU_decomposed = LU_decomp(matr);


  double** L = MakeMatr(LU_decomposed.at(0));
  double** U = MakeMatr(LU_decomposed.at(1));

  cout<<"L:"<<endl;
  PrintMatr(L);
  cout<<"U:"<<endl;
  PrintMatr(U);

  for(int i=0;i<dim;i++){
    delete [] matr[i];
    delete [] L[i];
    delete [] U[i];
    delete [] matr_product[i];
  }

  delete[] matr;
  delete [] U;
  delete [] L;
  delete [] vec;
  delete [] matr_product;
  delete [] vec_product;
}
