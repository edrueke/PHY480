\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage{cite}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage[margin=1.0in]{geometry}
\usepackage{enumitem}
\usepackage{listings}

\numberwithin{equation}{section}

\title{Numerical Solutions to the Problem of the Solar System}
\author{Elizabeth Drueke}

\begin{document}
\maketitle

\begin{abstract}


a
\end{abstract}

\section{Introduction}
\label{sec:intro}

For as long as humans have been on the earth, we have been looking to the sky.  Ancient peoples relied on the stars and planets to tell when the seasons were changing, so they would know when was a good time to plant crops for food.  A little later, the stars were used by mariners as a compass, guiding them across the seas.  
\\\indent Today still we look towards the skies.  However, we arguably know more about them.  We know that our solar system is not the center of the universe, nor are we the center of our solar system.  We know that our sun is a middle-sized star, and without its light and heat there would be no life on earth.  We know that the rotation of the planets around the sun is dictated by Newton's Second Law, and, with this, we can calculate the trajectory of the planetary bodies around us.  
\\\indent Here, we present two such calculations.  Using the Verlet and $4^{th}$-Order Runge-Kutta (RK4) Methods, we investigate the motion of the planets around the sun.  We begin by presenting the simple theory of planetary motion in Section~\ref{sec:theory}.  Then we discuss the Verlet and RK4 methods in Sections~\ref{subsec:verlet} and~\ref{subsec:rk4}.  After this, we discuss the framework and the algorithm developed particularly in this project in Section~\ref{sec:algorithm}.  Finally, results and benchmarks for the code are discussed in Section~\ref{sec:results}.

\section{Theory}
\label{sec:theory}

As mentioned in Section~\ref{sec:intro}, the movements of planets are dictated by Newton's Second Law, which states

$$\vec{F} = m\vec{a}.$$

\noindent Thus, we have a second order differential equation:

$$m\frac{d^{2}\vec{x}}{dt^{2}} = \vec{F}$$

\noindent where $\vec{F}$ is the sum of the forces on the planet in question.  In particular, the force of one planet on another is given by

\begin{equation}
\label{eq:bigg}
\vec{F} = -\frac{Gm_{1}m_{2}}{r^{2}}\hat{r}
\end{equation}

\noindent where $G = 6.67\times10^{-11} m^{3}kg^{-1}s^{-2}$ is the gravitational constant, $m_{1,2}$ are the masses of the two planets, and $r$ is the distance between the planets.
\\\indent Now, we want to be able to use some sort of discretized version of this in order to use a computer to approximate a numerical solution to this problem.  Our first step is then to look at Eq.~\ref{eq:bigg} component-wise (ie. look at the $x$- and $y$- components separately).  In particular, we should have

$$
m\frac{d^{2}x}{dt^{2}} = F_{x} \text{ and } m\frac{d^{2}y}{dt^{2}} = F_{y}
$$

\noindent Noting that $\vec{r}=x\hat{x}+y\hat{y}$, this gives us that

$$
F_{x} = -\frac{Gm_{1}m_{2}x}{r^{3}}\text{ and } F_{y} = -\frac{Gm_{1}m_{2}y}{r^{3}}
$$

\noindent Thus we have two coupled second-order differential equations:

\begin{equation}
\label{eq:diffeqs1}
\frac{d^{2}x}{dt^{2}} = -\frac{Gm_{1}x}{r^{3}}\text{ and } \frac{d^{2}y}{dt^{2}} = -\frac{Gm_{1}y}{r^{3}}
\end{equation}

\noindent or, alternatively, four coupled first-order differential equations:

\begin{equation}
\label{eq:diffeqs2}
\begin{align}
\frac{dx}{dt} = v_{x} &\text{, }&\frac{dv_{x}}{dt}=-\frac{Gm_{1}x}{r^{3}}, \\
\frac{dy}{dt} = v_{y} &\text{, }&\frac{dv_{y}}{dt}=-\frac{Gm_{1}y}{r^{3}}.
\end{align}
\end{equation}

\\\indent In this analysis, we first investigate the unperturbed earth-sun system.  In this case, Eq.~\ref{eq:bigg} becomes

\begin{equation}
\label{eq:earthsunbigg}
\vec{F} = \frac{GM_{\odot}m_{E}}{r^{2}}\hat{r}
\end{equation}

\noindent where $m_{E}$ is the mass of the earth and $M_{\odot}$ is the mass of the sun.  Assuming a circular orbit, we can say that 

$$a = \frac{mc^{2}}{r},$$

\noindent and so we have

$$\frac{mv^{2}}{r} = \frac{GM_{\odot}m_{E}}{r^{2}}$$

\noindent or

$$v^{2}r = GM_{\odot} = 4\pi^{2} AU^{2}yr^{-2}.$$

\noindent Thus, for the unperturbed earth-sun system, we wish to investigate

\begin{equation}
\label{eq:earthsun}
\frac{d^{2}x}{dt^{2}} = -\frac{4\pi^{2}x}{r^{3}} \text{ and } \frac{d^{2}y}{dt^{2}} = -\frac{4\pi^{2}y}{r^{3}}.
\end{equation}

\\\indent We will also want to look at adding other planets to our solar system.  After all, the unperturbed earth-sun system is really to simplistic to be a reasonable approximation for how the solar system.  Noting that

$$Gm_{p} = GM_{\odot}\frac{m_{p}}{M_{\odot}}=4\pi^{2}\frac{m_{p}}{M_{\odot}},$$

\noindent we have, for planet $p\prime$,

\begin{equation}
\label{eq:multiplanet}
\begin{align}
a_{x} &=  \frac{dv_{x}}{dt} =&  -\frac{4\pi^{2}}{r_{p\prime\odot}^{3}}\left(x_{p\prime} - x_{\odot}\right) - \frac{4\pi^{2}}{M_{\odot}}\sum_{p\neq p\prime}\frac{m_{p}\left(x_{pprime} - x_{p}\right)}{r_{pp\prime}^{3}}, \\
a_{y} &=  \frac{dv_{y}}{dt} =&  -\frac{4\pi^{2}}{r_{p\prime\odot}^{3}}\left(y_{p\prime} - y_{\odot}\right) - \frac{4\pi^{2}}{M_{\odot}}\sum_{p\neq p\prime}\frac{m_{p}\left(y_{p\prime} - y_{p}\right)}{r_{pp\prime}^{3}}.
\end{align}
\end{equation}

\\\indent The solution of Eq.~\ref{eq:earthsun} is fairly straightforward (we are only really looking at two coupled second-order differential equations), although still not simple by any means.  However, the solution to Eq.~\ref{eq:multiplanet} is impossible to get by hand.  The number of couple equations will be twice the number of planets in the solar system.  Thus, to solve either system, it is useful to turn to numerical approximations and computer algorithms.  In particular, we look into the Verlet and RK4 methods as means by which to solve the system.

\subsection{Verlet Method}
\label{subsec:verlet}

It is a common practice in creating computer algorithms to solve complex problems to discretize the equations in order to get something more concrete to work with.  In this case, we will discretize using the Taylor Series expansion.  That is, we will have

\begin{equation}
\label{eq:taylor}
x\left(t+h\right) = x\left(t\right)+hx^{'}\left(t+h\right)+\frac{h^{2}}{2}x^{'}^{'}\left(t+h\right)+O\left(h^{3}\right)
\end{equation}

\noindent Thus, we can say, letting $x_{i} = x\left(t_{0}+hi\right)$, that, for planet $p\prime$ in the multi-planet system, 

\begin{equation}
\label{eq:discx}
\begin{align}
x_{i+1} &= x_{i}+hv_{i}+\frac{h^{2}}{2}v_{i}^{'}+O\left(h^{3}\right) \\
&= x_{i}+hv_{i}+\frac{h^{2}}{2}\left(-\frac{4\pi^{2}}{r_{p\prime\odot}_{i}^{3}}\left(x_{p\prime}-x_{\odot}\right)_{i} - \frac{4\pi^{2}}{M_{\odot}}\sum_{p\neq p\prime}\frac{m_{p}\left(x_{p\prime}-x_{p}\right)_{i}}{r_{pp\prime}_{i}^{3}}\right)+O\left(h^{3}\right).
\end{align}
\end{equation}

\noindent We can similarly discretize the velocity of planet $p\prime$ to find

\begin{equation}
\label{eq:discv}
\begin{align}
v_{i+1} &= v_{i}+\frac{h}{2}\left(v_{i+1}^{'}+v_{i}^{'}\right)+O\left(h^{2}\right) \\
&= v_{i}+\frac{h}{2}\left(-4\pi^{2}\left(\frac{\left(x_{p\prime}-x_{\odot}\right)_{i}}{r_{p\prime\odot}_{i}^{3}}+\frac{\left(x_{p\prime}-x_{\odot}\right)_{i+1}}{r_{p\prime\odot}_{i+1}^{3}}\right) \\
 &- \frac{4\pi^{2}}{M_{\odot}}\sum_{p\neq p\prime}m_{p}\left(\frac{\left(x_{p\prime}-x_{p}\right)_{i}}{r_{pp\prime}_{i}^{3}} +  \frac{\left(x_{p\prime}-x_{p}\right)_{i+1}}{r_{pp\prime}_{i+1}^{3}}\right)\right)+O\left(h^{3}\right).
\end{align}
\end{equation}

\noindent In the case of the unperturbed earth-sun system, Eqs.~\ref{eq:discx} and~\ref{eq:discv} simplify to

$$
x_{i+1} =  x_{i}+hv_{i}+\frac{h^{2}}{2}\left(-\frac{4\pi^{2}}{r_{p\prime\odot}_{i}^{3}}\left(x_{p\prime}-x_{\odot}\right)_{i}\right)+O\left(h^{3}\right)
$$

\noindent and

$$
v_{i+1} =  v_{i}+\frac{h}{2}\left(-4\pi^{2}\left(\frac{\left(x_{p\prime}-x_{\odot}\right)_{i}}{r_{p\prime\odot}_{i}^{3}}+\frac{\left(x_{p\prime}-x_{\odot}\right)_{i+1}}{r_{p\prime\odot}_{i+1}^{3}}\right)\right)+O\left(h^{3}\right).
$$

\\\indent Together, Eqs.~\ref{eq:discx} and~\ref{eq:discv} make up what is known as the Verlet method \textbf{cite lecture notes}.  With the introduction of the velocity Verlet method, this method is self-starting.

\subsection{Fourth-Order Runge-Kutta}
\label{subsec:rk4}

The RK4 method is a bit more precise than the Verlet method discussed in Section~\ref{subsec:verlet}.  It is based on the observation that, for

$$
\frac{dy}{dt} = f\left(t,y\right),
$$

\noindent we can say

$$
y\left(t\right) = \int f\left(t,y\right)dt.
$$

\noindent Discretizing, this yields

$$
y_{i+1}=y_{i} + \int_{t_{i}}^{t_{i+1}}f\left(t,y\right)dt.
$$

\noindent Letting $y_{i+1/2} = y\left(t_{i}+h/2\right)$, and using the midpoint formula for the integral, we find 

$$
\int_{t_{i}}^{t_{i+1}}f\left(t,y\right)dt \approx hf\left(t_{i+1/2},y_{i+1/2}\right)+O\left(h^{3}\right).
$$

\noindent Thus, we have

$$
y_{i+1}=y_{i} +  hf\left(t_{i+1/2},y_{i+1/2}\right)+O\left(h^{3}\right).
$$

\noindent However, it is clear that, in order to use this method, we must have some idea of what $y_{i+1/2}$ is.  To get this quantity, we use Euler's method to approximate it:

$$
y_{i+1/2} \approx y_{i}+\frac{h}{2}f\left(t_{i},y_{i}\right).
$$

\\\indent This leads us to the $2^{nd}$-Order Runge-Kutta Method, or RK2, which says that, for

\begin{equation}
\label{eq:rk2part1}
\begin{align}
k_{1} & = hf\left(t_{i},y_{i}\right) \\
k_{2} & = hf\left(t_{i+1/2},y_{i}+k_{1}/2\right),
\end{align}
\end{equation}

\noindent we have

\begin{equation}
\label{eq:re2part2}
y_{i+1} \approx y_{i}+k_{2}+O\left(h^{2}\right).
\end{equation}

\\\indent We can go through another similar sequence of steps to get to RK4, culminating in the following definitions:

\begin{equation}
\label{eq:rk4}
\begin{align}
k_{1} & = hf\left(t_{i},y_{i}\right) \\
k_{2} & = hf\left(t_{i}+h/2,y_{i}+k_{1}/2\right), \\
k_{3} & = hf\left(t_{i}+h/2,y_{i}+k_{2}/2\right), \\
k_{4} & = hf\left(t_{i}+h,y_{i}+k_{3}\right), \\
y_{i+1} & \approx y_{i}+\left(1/6\right)\left(k_{1}+2k_{2}+2k_{3}+k_{4}\right)+O\left(h^{4}\right).
\end{align}
\end{equation}

\section{The Algorithm}
\label{sec:algorithm}

The code developed for this project is written in C++ using the ROOT \textbf{cite root} framework for plotting.  Code from \textbf{project 1 cite} and \textbf{project 2 cite} was reused, particularly the \textttt{thevec} and \textttt{themat} classes defined in \textttt{classes.C}.  However, several new classes and functions were designed specifically for the problem of solving the solar system.
\par In header file \texttt{odesolvers.h} we define the \texttt{Verlet} and \texttt{RK4} functions, each of which return two \texttt{thevec}s, one of the discretized position solution and the other of the discretized velocity solution.  

\begin{itemize}
\item The \texttt{Verlet} method begins by determining a step size \texttt{h} according to certain inputs (the initial time \texttt{t0} and final time \texttt{tf}, as well as the number of steps \texttt{nsteps}) as

\begin{verbatim}
   h = (1.0*tf-1.0*t0)/(1.0*nsteps);
\end{verbatim}

and then sets the first available position point to be

\begin{verbatim}
   pos[0] = x[0];
   pos[1] = pos[0]+h*v0
\end{verbatim}

for some given initial position \texttt{x0}.  It then iterates over integers less than \texttt{nsteps} in order to completely solve the position vector:

\begin{verbatim}
   for(int i=2;i<nsteps+1;i++){
        pos[i] = 2*pos[i-1]-pos[i-2]-a*pow(h,2)*pos[i-1]/r;
   }
\end{verbatim}

where \texttt{a} is the $4\pi^{2}$ factor.  It then solves for the velocity vector by setting

\begin{verbatim}
   vel[0] = v0;
\end{verbatim}

for some given initial velocity \texttt{v0} and then iterating again over integers less than \texttt{nsteps} as follows:

\begin{verbatim}
   for(int i=1;i<nsteps;i++){
        vel[i] = vel[i-1]+(h/2)*a*pos[i]/pow(r,3)-a*pos[i-1]/pow(r,3);
   }
\end{verbatim}

where \texttt{r} is the averate distance between the planet and the sun.
\item The \texttt{RK4} algorithm computes the step size \texttt{h} and initializes the position and velocity vectors as the \texttt{Verlet} algorithm does, and then iterates over integers less than \texttt{nsteps} as follows:

\begin{verbatim}
   for(int i=0;i<nsteps;i++){
        double k1p = h*vel[i-1];
        double k1v = h*a*pos[i-1]/pow(r,3);

        double k2p = h*vel([i-1]+k1v/2);
        double k2v = -h*a*(pos[i-1]+k1p/2)/pow(r,3);

        double k3p = h*(vel[i-1]+k2v/2);
        double k3v = -h*a*(pos[i-1]+k2p/2)/pow(r,3);

        double k4p = h*(vel[i-1]+k3v);
        double k4v = -h*a*(pos[i-1]+k3p)/pow(r,3);

        pos[i] = pos[i-1]+(1/6)*(k1p+2*k2p+2*k3p+k4p);
        vel[i] = vel[i-1]+(1/6)*(k1v+2*k2v+2*k3v+k4v);
   }
\end{verbatim}

\end{itemize}
\noindent These algorithms clearly are only designed to solve one direction ($x$ or $y$) at a time, and are designed only to handle the earth-sun system with the earth in an assumed circular orbit.  The multi-body problem was solved by a similar code in \texttt{solar\_system.C}.
\par We also, for this project, found it prudent to define two new classes: \texttt{planet} and \texttt{solar\_system}.  The \texttt{planet} class is declared and defined in \texttt{planets.h} and \texttt{planets.C}.  Each object of type \texttt{planet} has associated it with it a \texttt{mass} (\texttt{double} of mass in kilograms), \texttt{dist\_sun} (\texttt{double} of the average distance between the planet and the sun, \texttt{name} (\texttt{string} of the name of the planet), \texttt{acc} (\texttt{double} of the acceleration the planet would have in a pure, idealized sun-planet system with a circular orbit), \texttt{v0} (\texttt{double} of the average velocity of the planet around the sun), and eight \texttt{thevec} which are used to hold the positions and velocities in the $x$- and $y$-directions after they are solved for by the \texttt{RK4} and \texttt{Verlet} algorithms.  These last objects, however, are not directly used by the \texttt{planet} class.  It only became obvious after the class had been designed, during the designing stage of the \texttt{solar\_system} class, that it would be convenient for the \texttt{planet} objects to have these components.  Thus they are used solely by the \texttt{solar\_system} class as discussed below. 
\par The \texttt{planet} class has several constructors as well as functions:

\begin{itemize}
\item \texttt{print()}, which returns a string one might use to print the planet information to screen,
\item \texttt{kinetic()}, which calculates the kinetic energy of the planet from a velocity which is taken as an argument,
\item \texttt{potential()}, which calculates the potential energy of the planet from a distance from the sun which is taken as an argument,
\item \texttt{ang\_mom()}, which calculates the angular momentum of the planet from a distance from the sun and a velocity, which are both taken as arguments.
\end{itemize}

\noindent These algorithms are all fairly straightforward and do not merit discussion here.
\par The \texttt{solar\_system} class is really the meat of the code.  Defined and declared in \texttt{solar\_system.h} and \texttt{solar\_system.C}, this class was designed to solve the multi-body problem in full.  Each object of type \texttt{solar\_system} has associated with it \texttt{planets} (\texttt{vector<planet*>} of the planets to be included in the solar system), \texttt{nsteps} (\texttt{int} of the number of steps to be used by the Verlet and RK4 algorithms discussed below), \texttt{tf} (\texttt{double} of the final time to be used by the RK4 and Verlet algorithms), and \texttt{originx} and \texttt{originy} (\texttt{double} which describe the $x$- and $y$-components of the position of the origin to be used in the calculations).  This class also has several constructors, as well as the following functions:

\begin{itemize}

\item \texttt{Add()}, which adds a planet, taken as an argument, to the solar system
\item \texttt{Solve\_Verlet()}, which solves the multi-body solar system using the Verlet algorithm.  In particular, after calculating the step size as

\begin{verbatim}
   double h = tf/nsteps;
\end{verbatim}

and defining the $-4\pi^{2}$ factor as \texttt{fact} and the mass of the sun as \texttt{msun}, this algorithm creates a dynamic array of the planets in \texttt{planets} and initializes their position and velocity \texttt{thevec} objects by using their \texttt{v0} and \texttt{dist\_sun} and the initial $x$-velocity and $y$-positions, respectively.  Then, there is a \texttt{for} loop which iterates over integers \texttt{i} which are less than \texttt{nsteps}.  For each \texttt{i}, it goes calculates the both the position at $i$ for every planet in the solar system:

\begin{verbatim}
   for(unsigned int it=0;it<planets.size();it++){
       
      planet myplan = theplanets[it];

      double vx_prev = myplan.velocitiesx_v[i-1];
      double vy_prev = myplan.velocitiesy_v[i-1];
      double x_prev = myplan.positionsx_v[i-1];
      double y_prev = myplan.positionsy_v[i-1];
      
      double r_prev = sqrt(pow(x_prev-originx,2)
                                +pow(y_prev-originy,2));
      
      double x = x_prev+h*vx_prev;
      double y = y_prev+h*vy_prev;
      
      for(unsigned int m = 0;m<planets.size();m++){
	
         planet plan = theplanets[m];
	
         if(myplan != plan){
	  
            double xp_prev = plan.positionsx_v[i-1];
            double yp_prev = plan.positionsy_v[i-1];
  
            double rp_prev = sqrt(pow(x_prev-xp_prev,2)
                                         +pow(y_prev-yp_prev,2));
  
            x += (pow(h,2)/2)*fact*plan.mass
                     *(x_prev-xp_prev)/(msun*pow(rp_prev,3));
            y += (pow(h,2)/2)*fact*plan.mass
                     *(y_prev-yp_prev)/(msun*pow(rp_prev,3));
	  
         }
      }

   theplanets[it].positionsx_v[i]=x;
   theplanets[it].positionsy_v[i]=y;
\end{verbatim}

Then, the algorithm solves for the velocity at $i$ for each of the planets:

\begin{verbatim}
   for(unsigned int it = 0;it<planets.size();it++){
      
      planet myplan = theplanets[it];
      
      double vx_prev = myplan.velocitiesx_v[i-1];
      double vy_prev = myplan.velocitiesy_v[i-1];
      double x_prev = myplan.positionsx_v[i-1];
      double y_prev = myplan.positionsy_v[i-1];
      
      double r_prev = sqrt(pow(x_prev-originx,2)+pow(y_prev-originy,2));
      
      double x = myplan.positionsx_v[i];
      double y = myplan.positionsy_v[i];
      double newr = sqrt(pow(x-originx,2)+pow(y-originy,2));
    
      double vx = vx_prev;
      double vy = vy_prev;
      
      for(unsigned int m = 0;m<planets.size();m++){
	
         planet plan = theplanets[m];
	
         if(myplan != plan){
	  
            double xp_prev = plan.positionsx_v[i-1];
            double yp_prev = plan.positionsy_v[i-1];
	  
            double xp_cur = plan.positionsx_v[i];
            double yp_cur = plan.positionsy_v[i];
	  
            double rp_cur = sqrt(pow(x-xp_cur,2)+pow(y-yp_cur,2));
            double rp_prev = sqrt(pow(x_prev-xp_prev,2)
                                        +pow(y_prev-yp_prev,2));
	  
            vx += ((h/2)*fact*plan.mass/msun)*((x-xp_cur)/pow(rp_cur,3)
                       +(x_prev-xp_prev)/pow(rp_prev,3));
            vy += ((h/2)*fact*plan.mass/msun)*((y-yp_cur)/pow(rp_cur,3)
                       +(y_prev-yp_prev)/pow(rp_prev,3));
	  
         }
      }
      
      theplanets[it].velocitiesx_v.point[i] = vx;
      theplanets[it].velocitiesy_v.point[i] = vy;
    
   }
\end{verbatim}

Then, the algorithm redefines the planets in the \texttt{planets} vector so that their position and velocity Verlet \texttt{thevec}s are filled appropriately.
\item \texttt{Solve_RK4()} uses the RK4 algorithm to solve the multi-body problem.





\end{itemize}

\section{Results and Benchmarks}
\label{sec:results}



\section{Conclusions}
\label{sec:conclusions}



\section{Bibliography}
\label{sec:bib}

\begin{enumerate}

\item a

\end{enumerate}

\end{document}